{
  "code": 0,
  "data": {
    "records": [
      {
        "id": "1683090767360299010",
        "title": "零基础手把手带你阅读Redis源代码系列-ZSet底层原理详解（跳表SkipList）",
        "description": "带你阅读跳表源码",
        "content": ">之前就说了要来西索Redis，现在来辣！\n>\n>本文的部分内容参考自《小林Coding》，部分地方根据源代码进行剖析。\n>\n>Redis源码地址：https://github.com/redis/redis.git\n>\n>更多内容可以看我博客：https://cloud.tencent.com/developer/user/2871589\n\n\n## ZSet\n\n### 观其面\n\n和Set类似，但是新增了一个排序字段。\n\n![image-20230723015004842](http://gd.7n.cdn.wzl1.top/typora/img/image-20230723015004842.png)\n\n常用操作\n\n```bash\n# 往有序集合key中加入带分值元素\nZADD key score member [[score member]...]   \n# 往有序集合key中删除元素\nZREM key member [member...]                 \n# 返回有序集合key中元素member的分值\nZSCORE key member\n# 返回有序集合key中元素个数\nZCARD key \n# 为有序集合key中元素member的分值加上increment\nZINCRBY key increment member \n# 正序获取有序集合key从start下标到stop下标的元素\nZRANGE key start stop [WITHSCORES]\n# 倒序获取有序集合key从start下标到stop下标的元素\nZREVRANGE key start stop [WITHSCORES]\n# 返回有序集合中指定分数区间内的成员，分数由低到高排序。\nZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]\n# 返回指定成员区间内的成员，按字典正序排列, 分数必须相同。\nZRANGEBYLEX key min max [LIMIT offset count]\n# 返回指定成员区间内的成员，按字典倒序排列, 分数必须相同\nZREVRANGEBYLEX key max min [LIMIT offset count]\n```\n\n运算操作\n\n```bash\n# 并集计算(相同元素分值相加)，numberkeys一共多少个key，WEIGHTS每个key对应的分值乘积\nZUNIONSTORE destkey numberkeys key [key...] \n# 交集计算(相同元素分值相加)，numberkeys一共多少个key，WEIGHTS每个key对应的分值乘积\nZINTERSTORE destkey numberkeys key [key...]\n```\n\n### 应用场景\n\n#### 排行榜\n\n点赞数量和内容ID相关联，最后再根据ID去查，或者异步更新也可以\n\n为什么不存全部数据？部分数据会修改，那么可能导致value伪重复，加大了业务复杂度\n\n#### 电话、姓名区间排序\n\n使用有序集合的 `ZRANGEBYLEX` 或 `ZREVRANGEBYLEX` 可以帮助我们实现电话号码或姓名的排序，我们以 `ZRANGEBYLEX` （返回指定成员区间内的成员，按 key 正序排列，分数必须相同）为例。\n\n**注意：不要在分数不一致的 SortSet 集合中去使用 ZRANGEBYLEX和 ZREVRANGEBYLEX 指令，因为获取的结果会不准确。**\n\n*1、电话排序*\n\n我们可以将电话号码存储到 SortSet 中，然后根据需要来获取号段：\n\n```shell\n> ZADD phone 0 13100111100 0 13110114300 0 13132110901 \n(integer) 3\n> ZADD phone 0 13200111100 0 13210414300 0 13252110901 \n(integer) 3\n> ZADD phone 0 13300111100 0 13310414300 0 13352110901 \n(integer) 3\n```\n\n获取所有号码:\n\n```shell\n> ZRANGEBYLEX phone - +\n1) \"13100111100\"\n2) \"13110114300\"\n3) \"13132110901\"\n4) \"13200111100\"\n5) \"13210414300\"\n6) \"13252110901\"\n7) \"13300111100\"\n8) \"13310414300\"\n9) \"13352110901\"\n```\n\n获取 132 号段的号码：\n\n```shell\n> ZRANGEBYLEX phone [132 (133\n1) \"13200111100\"\n2) \"13210414300\"\n3) \"13252110901\"\n```\n\n获取132、133号段的号码：\n\n```shell\n> ZRANGEBYLEX phone [132 (134\n1) \"13200111100\"\n2) \"13210414300\"\n3) \"13252110901\"\n4) \"13300111100\"\n5) \"13310414300\"\n6) \"13352110901\"\n```\n\n*2、姓名排序*\n\n```shell\n> zadd names 0 Toumas 0 Jake 0 Bluetuo 0 Gaodeng 0 Aimini 0 Aidehua \n(integer) 6\n```\n\n获取所有人的名字:\n\n```shell\n> ZRANGEBYLEX names - +\n1) \"Aidehua\"\n2) \"Aimini\"\n3) \"Bluetuo\"\n4) \"Gaodeng\"\n5) \"Jake\"\n6) \"Toumas\"\n```\n\n获取名字中大写字母A开头的所有人：\n\n```shell\n> ZRANGEBYLEX names [A (B\n1) \"Aidehua\"\n2) \"Aimini\"\n```\n\n获取名字中大写字母 C 到 Z 的所有人：\n\n```shell\n> ZRANGEBYLEX names [C [Z\n1) \"Gaodeng\"\n2) \"Jake\"\n3) \"Toumas\"\n```\n\n### 究其身\n\ncv完了，现在来看看源码。\n\nZset 类型的底层数据结构是由**压缩列表或跳表**实现的：\n\n- 如果有序集合的元素个数小于 `128` 个，并且每个元素的值小于 `64` 字节时，Redis 会使用**压缩列表**作为 Zset 类型的底层数据结构；\n- 如果有序集合的元素不满足上面的条件，Redis 会使用**跳表**作为 Zset 类型的底层数据结构；\n\n**在 Redis 7.0 中，压缩列表数据结构已经废弃了，交由 listpack 数据结构来实现了。**\n\nlistpack和压缩列表在之前讲List的时候就已经讲过了，这里主要来讲一讲跳表。\n\n#### 跳表\n\n跳表是从链表的结构上面改进出来的，可以说是多层链表\n\n![image-20230723042434378](http://gd.7n.cdn.wzl1.top/typora/img/image-20230723042434378.png)\n\n图中头节点有 L0~L2 三个头指针，分别指向了不同层级的节点，然后每个层级的节点都通过指针连接起来：\n\n- L0 层级共有 5 个节点，分别是节点1、2、3、4、5；\n- L1 层级共有 3 个节点，分别是节点 2、3、5；\n- L2 层级只有 1 个节点，也就是节点 3 。\n\n下面我们来看看实际的结构\n\n如上图，记录头节点和尾节点~~（图上没有，后面细说）~~，我们封装在一起，成了整个链跳表体\n\n```c\ntypedef struct zskiplist {\n    struct zskiplistNode *header, *tail;\t// 头节点、尾节点\n    unsigned long length;\t\t\t\t\t// 跳表长度\n    int level;\t\t\t\t\t\t\t\t// 最高的层级\n} zskiplist;\n```\n\n那么节点又是怎么定义的呢？如果让我来做的话，我会用给一个数组来表示下一个节点（详细看上图），不过也确实是这样做的\n\n```c\n/* ZSETs use a specialized version of Skiplists */\ntypedef struct zskiplistNode {\n    sds ele;\t\t// 内容\n    double score;\t// 用于排序的字段，我们称之为权重\n    struct zskiplistNode *backward;\t//后向指针 前继\n    // level 数组中的每一个元素代表跳表的一层，也就是由 zskiplistLevel 结构体表示，比如 leve[0] 就表示第一层，leve[1] 就表示第二层。\n    struct zskiplistLevel {\n        struct zskiplistNode *forward;\t// 每层的前向指针 后继\n        unsigned long span;\t\t// 跨度\n    } level[];\t\n} zskiplistNode;\n```\n\n这里对前向和后向进行一个解释：\n\t\t其实就是一个双链表，不过后续指针是一个指针数组，前向指针是后继，后向指针是前继\n\n那么这个跨度是啥？\n**跨度**\n\n用于**计算这个节点在跳表中的排位**。具体怎么做的呢？因为跳表中的节点都是按序排列的，那么计算某个节点排位的时候，**从头节点点到该结点的查询路径上，将==沿途访问过==的所有层的跨度累加起来**，得到的结果就是目标节点在跳表中的排位。\n\n没懂？看上图，把这个节点前面的阶段求个前缀和，他们的结果就是跨度，也就是当前节点的编号。\n\n#### 跳表的创建\n\n```c\n// 定义最高层数 Redis 7.0 定义为 32，Redis 5.0 定义为 64，Redis 3.0 定义为 32\n#define ZSKIPLIST_MAXLEVEL 32 /* Should be enough for 2^64 elements */\n\n/* Create a new skiplist. */\nzskiplist *zslCreate(void) {\n    int j;\n    zskiplist *zsl;\n\n    zsl = zmalloc(sizeof(*zsl));\n    zsl->level = 1;\t\t\t// 初始只有一层\n    zsl->length = 0;\n    zsl->header = zslCreateNode(ZSKIPLIST_MAXLEVEL,0,NULL);\t// 创建一个节点，节点创建在后面讲\n    // 把每一层都初始化\n    for (j = 0; j < ZSKIPLIST_MAXLEVEL; j++) {\n        zsl->header->level[j].forward = NULL;\n        zsl->header->level[j].span = 0;\n    }\n    // 初始化跳表\n    zsl->header->backward = NULL;\n    zsl->tail = NULL;\n    return zsl;\n}\n```\n\n#### 节点创建\n\n```c\n/* Create a skiplist node with the specified number of levels.\n * The SDS string 'ele' is referenced by the node after the call. */\nzskiplistNode *zslCreateNode(int level, double score, sds ele) {\n    zskiplistNode *zn =\n        zmalloc(sizeof(*zn)+level*sizeof(struct zskiplistLevel));\n    zn->score = score;\n    zn->ele = ele;\n    return zn;\n}\n```\n\n#### 跳表的释放\n\n```c\n/* Free a whole skiplist. */\nvoid zslFree(zskiplist *zsl) {\n    zskiplistNode *node = zsl->header->level[0].forward, *next;\n\n    zfree(zsl->header);\t// 释放头节点\n    // 在初始化的时候直接指向了第一个元素\n    while(node) {\n        next = node->level[0].forward;\n        // 释放每一个节点\n        zslFreeNode(node);\n        node = next;\n    }\n    zfree(zsl);\n}\n\n/* Free the specified skiplist node. The referenced SDS string representation\n * of the element is freed too, unless node->ele is set to NULL before calling\n * this function. */\nvoid zslFreeNode(zskiplistNode *node) {\n    sdsfree(node->ele);\t// 释放member\n    zfree(node);\t// 释放节点\n}\n\n/* Free an sds string. No operation is performed if 's' is NULL. */\nvoid sdsfree(sds s) {\n    if (s == NULL) return;\n    s_free((char*)s-sdsHdrSize(s[-1]));\t// s_free就是z_free\n}\n// 呃呃呃，这不解释了\nvoid zfree(void *ptr) {\n#ifndef HAVE_MALLOC_SIZE\n    void *realptr;\n    size_t oldsize;\n#endif\n\n    if (ptr == NULL) return;\n#ifdef HAVE_MALLOC_SIZE\n    update_zmalloc_stat_free(zmalloc_size(ptr));\n    free(ptr);\n#else\n    realptr = (char*)ptr-PREFIX_SIZE;\n    oldsize = *((size_t*)realptr);\n    update_zmalloc_stat_free(oldsize+PREFIX_SIZE);\n    free(realptr);\n#endif\n}\n```\n\n#### 跳表节点查询过程\n\n查找一个跳表节点的过程时，跳表会从头节点的最高层开始，逐一遍历每一层。在遍历某一层的跳表节点时，会用跳表节点中的 SDS 类型的元素和元素的权重来进行判断，共有两个判断条件：\n\n- 如果当前节点的权重 < 要查找的权重时，跳表就会访问该层上的下一个节点。\n- 如果当前节点的权重 = 要查找的权重时，并且当前节点的 SDS 类型数据 < 要查找的数据时，跳表就会访问该层上的下一个节点。\n\n如果上面两个条件都不满足，或者下一个节点为空时，跳表就会使用目前遍历到的节点的 level 数组里的下一层指针，然后沿着下一层指针继续查找，这就相当于跳到了下一层接着查找。\n\n举个例子，下图有个 3 层级的跳表。\n\n![image-20230723053340966](http://gd.7n.cdn.wzl1.top/typora/img/image-20230723053340966.png)\n\n如果要查找「元素：abcd，权重：4」的节点，查找的过程是这样的：\n\n- 先从头节点的最高层开始，L2 指向了「元素：abc，权重：3」节点，这个节点的权重比要查找节点的小，所以要访问该层上的下一个节点；\n- 但是该层的下一个节点是空节点（ leve[2]指向的是空节点），于是就会跳到「元素：abc，权重：3」节点的下一层去找，也就是 leve[1];\n- 「元素：abc，权重：3」节点的 leve[1] 的下一个指针指向了「元素：abcde，权重：4」的节点，然后将其和要查找的节点比较。虽然「元素：abcde，权重：4」的节点的权重和要查找的权重相同，但是当前节点的 SDS 类型数据 > 要查找的数据，所以会继续跳到「元素：abc，权重：3」节点的下一层去找，也就是 leve[0]；\n- 「元素：abc，权重：3」节点的 leve[0] 的下一个指针指向了「元素：abcd，权重：4」的节点，该节点正是要查找的节点，查询结束。\n\n```c\n// 这里是查找的源码，来自下面新增节点的函数\n\tx = zsl->header;\n    //从顶层开始，遍历开始，每次移动不只是移动头节点的level，是所有节点的level，每次都是从上一次遍历到的节点开始\n    for (i = zsl->level-1; i >= 0; i--) {\n        /* store rank that is crossed to reach the insert position */\n        rank[i] = i == (zsl->level-1) ? 0 : rank[i+1];\t\t//如果从头开始，跨度为0，否则累加上一层已经计算的跨度\n        while (x->level[i].forward &&\n                (x->level[i].forward->score < score ||\t\t\t// 权值小于目标\n                    (x->level[i].forward->score == score &&\n                    sdscmp(x->level[i].forward->ele,ele) < 0)))\t// 当前节点的memer小于目标节点\n        {\n            rank[i] += x->level[i].span;\t\t//计算跨度\n            x = x->level[i].forward;\t\t\t//到下一个索引位置\n        }\n        update[i] = x;\t\t//记录当前层开始修改的节点的位置\n    }\n```\n\n\n\n#### 新增节点\n\n```c\n/* Insert a new node in the skiplist. Assumes the element does not already\n * exist (up to the caller to enforce that). The skiplist takes ownership\n * of the passed SDS string 'ele'. */\nzskiplistNode *zslInsert(zskiplist *zsl, double score, sds ele) {\n    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;\n    unsigned long rank[ZSKIPLIST_MAXLEVEL];\n    int i, level;\n\n    serverAssert(!isnan(score));\n    x = zsl->header;\n    //从顶层开始，遍历开始，每次移动不只是移动头节点的level，是所有节点的level，每次都是从上一次遍历到的节点开始\n    for (i = zsl->level-1; i >= 0; i--) {\n        /* store rank that is crossed to reach the insert position */\n        rank[i] = i == (zsl->level-1) ? 0 : rank[i+1];\t\t//如果从头开始，跨度为0，否则累加上一层已经计算的跨度\n        while (x->level[i].forward &&\n                (x->level[i].forward->score < score ||\t\t\t// 权值小于目标\n                    (x->level[i].forward->score == score &&\n                    sdscmp(x->level[i].forward->ele,ele) < 0)))\t// 当前节点的Memer小于目标节点\n        {\n            rank[i] += x->level[i].span;\t\t//计算跨度\n            x = x->level[i].forward;\t\t\t//到下一个索引位置\n        }\n        update[i] = x;\t\t//记录当前层开始修改的节点的位置\n    }\n    /* we assume the element is not already inside, since we allow duplicated\n     * scores, reinserting the same element should never happen since the\n     * caller of zslInsert() should test in the hash table if the element is\n     * already inside or not. */\n \t// 假设要插入的元素在跳跃表中尚不存在，因为跳跃表允许有相同的分值（score）。\n    // 再次插入相同的元素是不应该发生的，因为调用 zslInsert() 函数的调用者应该在哈希表（或其他数据结构）中先测试元素是否已经存在。\n    // 在跳跃表中，允许多个节点具有相同的分值，但它们的元素值必须不同。\n    level = zslRandomLevel();\t//随机生成一个层数\n    if (level > zsl->level) {\t\t\n        // 如果这个level达到新高，那么往上面走，走到顶全部初始化（你可以理解为对level进行扩容）\n        for (i = zsl->level; i < level; i++) {\n            rank[i] = 0;\n            update[i] = zsl->header;\n            // 新的level,那么再old_level到level之间的跨度每层都是length\n            update[i]->level[i].span = zsl->length;\n        }\n        zsl->level = level;\n    }\n    x = zslCreateNode(level,score,ele);\t// 创建一个新的节点\n    for (i = 0; i < level; i++) {\n        //插入节点（基础知识：单链表的节点插入），修改第Li层的后继\n        x->level[i].forward = update[i]->level[i].forward;\t\n        update[i]->level[i].forward = x;\n\n        /* update span covered by update[i] as x is inserted here */\n        // (rank[0] - rank[i])为新节点到前一层节点的跨度差\n        // update[i]->level[i].span 表示的是原本前一个节点到后一个节点建的跨度\n        // 这里新来了一个节点，前一个节点新节点的跨度是rank[0] - rank[i]，另外一个就互补，见一下就可以了\n        x->level[i].span = update[i]->level[i].span - (rank[0] - rank[i]);\n        // 修改前一个节点的跨度，但是这个节点本身也算一个系欸但，所以要加1\n        update[i]->level[i].span = (rank[0] - rank[i]) + 1;\n    }\n\n    /* increment span for untouched levels */\n    // 前面我们只修改了同层，上面的每一层因为中间多了一个，所以跨度加一\n    for (i = level; i < zsl->level; i++) {\n        update[i]->level[i].span++;\n    }\n\t// 修改x的前继指针\n    x->backward = (update[0] == zsl->header) ? NULL : update[0];\n    if (x->level[0].forward)\n        x->level[0].forward->backward = x;\t// 只修改最下面一层的\n    else\n        zsl->tail = x;\t//把x放在最后\n    zsl->length++;\n    return x;\n}\n```\n\n#### 删除节点\n\n```c\n/* Delete an element with matching score/element from the skiplist.\n * The function returns 1 if the node was found and deleted, otherwise\n * 0 is returned.\n *\n * If 'node' is NULL the deleted node is freed by zslFreeNode(), otherwise\n * it is not freed (but just unlinked) and *node is set to the node pointer,\n * so that it is possible for the caller to reuse the node (including the\n * referenced SDS string at node->ele). */\nint zslDelete(zskiplist *zsl, double score, sds ele, zskiplistNode **node) {\n    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;\n    int i;\n\n    x = zsl->header;\n    // 这里再将新增的时候讲过了\n    for (i = zsl->level-1; i >= 0; i--) {\n        while (x->level[i].forward &&\n                (x->level[i].forward->score < score ||\n                    (x->level[i].forward->score == score &&\n                     sdscmp(x->level[i].forward->ele,ele) < 0)))\n        {\n            x = x->level[i].forward;\n        }\n        update[i] = x;\n    }\n    /* We may have multiple elements with the same score, what we need\n     * is to find the element with both the right score and object. */\n    x = x->level[0].forward;\n    if (x && score == x->score && sdscmp(x->ele,ele) == 0) {\n        // 进行节点删除，并且把关联系欸但进行修改\n        zslDeleteNode(zsl, x, update);\n        if (!node)\n            // 把空间释放\n            zslFreeNode(x);\n        else\n            *node = x;\n        return 1;\n    }\n    return 0; /* not found */\n}\n```\n\n##### 解决连锁反应\n\n```c\nvoid zslDeleteNode(zskiplist *zsl, zskiplistNode *x, zskiplistNode **update) {\n    int i;\n    for (i = 0; i < zsl->level; i++) {\n        if (update[i]->level[i].forward == x) {\n            update[i]->level[i].span += x->level[i].span - 1;\n            update[i]->level[i].forward = x->level[i].forward;\n        } else {\n            update[i]->level[i].span -= 1;\n        }\n    }\n    if (x->level[0].forward) {\n        x->level[0].forward->backward = x->backward;\n    } else {\n        zsl->tail = x->backward;\n    }\n    while(zsl->level > 1 && zsl->header->level[zsl->level-1].forward == NULL)\n        zsl->level--;\n    zsl->length--;\n}\n```\n\n",
        "category": "文章",
        "cover": "https://pic.code-nav.cn/post_cover/1608208038794100737/cV0PL48v-image-20230723042434378.png",
        "language": null,
        "viewNum": 4,
        "thumbNum": 1,
        "favourNum": 0,
        "commentNum": 0,
        "priority": 0,
        "userId": "1608208038794100737",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-07-23T12:24:43.000+00:00",
        "updateTime": "2023-07-24T05:22:19.000+00:00",
        "user": {
          "id": "1608208038794100737",
          "planetCode": "14757",
          "userName": "Karos",
          "userAvatar": "https://pic.code-nav.cn/user_avatar/1608208038794100737/n43g3wnh-QQ截图20230220091409.png",
          "gender": 1,
          "userProfile": "爱好 唱 跳 rap和篮球\uD83C\uDFC0",
          "userRole": "vip",
          "interests": [],
          "place": "四川",
          "birthday": "2003-02-11",
          "school": null,
          "major": "物联网工程",
          "education": "本科",
          "graduationYear": 2025,
          "jobStatus": "在校",
          "company": "嘉丽顿",
          "job": "后端",
          "workYear": -2,
          "direction": "后端",
          "goal": "实习",
          "github": "https://github.com/karosown",
          "blog": "https://www.wzl1.top/",
          "score": 10,
          "coin": 100,
          "followeeNum": 0,
          "followNum": 0,
          "followStatus": null,
          "vipExpireTime": "2024-02-02T23:45:23.000+00:00",
          "lastLoginTime": null,
          "createTime": "2022-12-28T21:07:30.000+00:00",
          "updateTime": "2023-07-12T15:23:52.000+00:00"
        },
        "tags": [
          "文章",
          "Redis",
          "数据库",
          "数据结构"
        ],
        "fileList": null,
        "videoList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1682013544297533441",
        "title": "java学习之运算符",
        "description": null,
        "content": "1. 算术运算符\n\n![image.png](https://pic.code-nav.cn/post_picture/1673111457186713601/N3jHBGCI-image.png)\n\n\n2. 赋值运算符\n   1. 语法结构: 变量 = 表达式的值或常量值.\n```java\n// 把常量17赋值给int类型的变量a\nint a = 17;\nSystem.out.println(\"a=\" + a);//a=17\n// += 把左边和右边的数据进行运算，最后赋值左边变量\na += 10;// 相当于a = a + 10\nSystem.out.println(\"a=\" + a);//a=27\n```\n\n3. 比较运算符\n   1. 作用: 比较变量或常量 表达式之间的大小关系,**结果都是Boolean类型.**\n   2. 语法格式: boolean result = 表达式A 比较运算符 表达式B\n| 运算符 | 运算规则 |\n| --- | --- |\n|     == | 相等于 |\n|      != | 不等于 |\n|      < | 小于 |\n|       > | 大于 |\n|      <= | 小于等于 |\n|      >= | 大于等于 |\n\n4. 三元运算符\n:::danger\n\n   1. **语法格式：结果数据类型 变量名 = boolean表达式 ？ 结果A ：结果B。**\n   2. **结果A和结果B 的数据类型需要一样。**\n   3. **必须定义变量接受运算的结果**\n:::\n```java\n//判断num取模是否等于0,如果等于0 B就等于true.\nBoolean B = num % 2 == 0 ? \"true\":\"false\";\n```\n\n5. 逻辑运算符\n>    1. 语法格式：boolean result = boolean表达式A 逻辑运算符 boolean表达式B;\n\n>    2. &&和  ||的执行效率更高，当前者可以判断时，不用执行后者。\n\n>    3. &和&&，| 和 | |的运算结果一样。\n\n| 运算符 | 运算规则 |  |\n| --- | --- | --- |\n| & | 与 | true & false--->false, 有false则为false |\n| &#124; | 或 | true &#124; false--->true ,有true则为true |\n| ！ | 非 | ！true--->false，将结果反转 |\n| ^ | 异或 | true ^false--->true，当两个结果不一样就为true |\n| && | 短路与 | true && false --->false，前者为true，则判断后者 |\n| &#124;&#124; | 短路或 | true  &#124; &#124; false--->true，前者为false，则判断后者 |\n\n> **注：() 的优先级最高，赋值运算符优先级最低；赋值运算符的 **\n> **运算方向从右向左。**\n\n",
        "category": "文章",
        "cover": null,
        "language": null,
        "viewNum": 4,
        "thumbNum": 2,
        "favourNum": 0,
        "commentNum": 0,
        "priority": 0,
        "userId": "1673111457186713601",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-07-20T13:04:13.000+00:00",
        "updateTime": "2023-07-22T10:20:38.000+00:00",
        "user": {
          "id": "1673111457186713601",
          "planetCode": "24251",
          "userName": "小白学it",
          "userAvatar": "https://pic.code-nav.cn/user_avatar/1673111457186713601/deuZEvYh-v2-44a47c4b5f6b6f8cec8ee51e645736ac_720w.webp",
          "gender": null,
          "userProfile": null,
          "userRole": "vip",
          "interests": [],
          "place": "cq",
          "birthday": "2002-05-14",
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": null,
          "direction": "后端",
          "goal": "社招",
          "github": null,
          "blog": null,
          "score": 0,
          "coin": 0,
          "followeeNum": 1,
          "followNum": 2,
          "followStatus": null,
          "vipExpireTime": "2024-06-25T23:22:50.000+00:00",
          "lastLoginTime": null,
          "createTime": "2023-06-25T23:30:30.000+00:00",
          "updateTime": "2023-07-20T06:22:21.000+00:00"
        },
        "tags": [
          "文章",
          "后端",
          "Java",
          "笔记"
        ],
        "fileList": null,
        "videoList": [],
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1680826349238882305",
        "title": "给学弟妹们的 10 个秋招建议！",
        "description": null,
        "content": "大家好，我是鱼皮。最近很多大公司的提前批陆陆续续开启了，说明秋招已经拉开了序幕，大家要准备起来了。\n\n所以我也赶紧写了一篇文章，结合自己曾经大厂求职的经验，并且从招聘方的角度，给学弟妹们一些秋招找工作的实质性建议，希望对大家有帮助。\n\n这次先分享 10 条建议，目标是尽量帮大家进大厂，所以部分建议对大多数同学来说可能会比较高。\n\n注意，以下建议不需要全部都做到，只要你能做到 **5 点及以上** ，你的秋招大概率会圆满上岸！\n\n\n\n### 1、早就是机会\n\n做任何事情都是一样的，准备和行动地越早，机会就越大。\n\n具体怎么 “早” 呢？\n\n首先， **能秋招，不春招！**\n\n之前有同学问我：鱼皮，我才刚学 Java 两个月，还要准备秋招么？是不是直接准备明年的春招就好了？\n\n千万别！\n\n即使你觉得自己在秋招截止前没法准备好，也不要把目标直接就定为 “明年的春招”。相信大家都是这样的，给自己定的目标越远，越容易拖延。\n\n如果你是今年有机会参与秋招的应届生，就把目标定为 “秋招上岸”，哪怕时间紧一点，不要犹豫，抓紧去学、去突击，而不是直接放弃。\n\n因为等到春招的时候，秋招已经上岸的同学、考研结束的同学、又准备了半年的同学都会一起来竞争越来越少的岗位，而且形式会更不明朗。\n\n所以早早行动起来，才是 “破卷” 的第一要义！\n\n另外，大家已经可以持续关注和寻找机会了，提前到网上了解一些公司开放招聘的时间、线上线下的宣讲会等，提前做好投递简历准备，而不是等到公司正式开放招聘，才去看公司的要求、再去写简历。\n\n> 另外还有一个我个人的行动准则，加引号是因为仅供参考。那就是在心态上 “别给自己留退路”，别老想着自己这件事做不成了还有其他的选择，而是要把所有的精力都放在秋招上，全力冲刺。\n\n\n\n### 2、一专多长\n\n因为如今网上的学习教程和项目教程都太多了，会导致大家的简历和经历没有什么区分度。\n\n想象一下，如果你在刷短视频，看到很多发量差不多的程序员在讲差不多的知识，可能一秒钟就划走了；但如果突然有一位光头强者、或者一位漂亮的小姐姐（女装大佬）在讲知识，那么你大概率会忍不住多刷几秒。\n\n面试官或 HR 看我们的简历也是一样的，如果我们简历上的技术千篇一律，都是大家耳熟能详的，而且写得又都差不多，那么很快就被他们 “划走了”。\n\n所以，建议大家在学完主流的开发技术之余，选择 **至少一个** 技术去深入学习，作为你个人的专长来吸引面试官。\n\n比如 MySQL 数据库，大家都会写 “熟悉索引、事务、性能优化” 等；但如果你阅读过一些 MySQL 高级书籍，可以去写你对查询优化器、MySQL 高可用、数据备份恢复、底层索引优化的理解和实践。从 “学习者” 变成 “实践者”，再从 “实践者” 变成 “研究者”，你的优势就会被放大。\n\n一个比较推荐的路子就是建议大家去阅读某个技术的高级书籍，了解其底层原理后，试着阅读 GitHub 上的简化版底层实现源码，再去阅读官方开源代码，并尝试提出一些 PR。\n\n如果你能给知名项目成功贡献 PR，那基本就稳了。\n\n\n\n### 3、分清主次\n\n大家刚准备秋招的时候，基本都会面临一个问题：我滴妈呀，八股文这么多，怎么背的完呀？！从哪开始背啊？！\n\n更可怕的是，你会发现八股文是越背越多的。。。\n\n其实完全不用慌，网上的八股文多，是因为随着时间持续不断积累和完善，但并不是说你要去背完所有的八股文。\n\n我们要做的是， **从我们自身的简历出发** ， **优先** 锁定可能会考到自己身上的八股文，分清主次。\n\n举个例子，你在简历上写了 “熟悉 Redis 的 RDB 和 AOF 机制”、并且项目中又运用到了 Redis。那么面试官大概率会考察 Redis 相关的八股文，你就针对性地去搜集和准备 Redis 相关的题目即可。\n\n无论你的时间多或少，都应该这么做。而不是别人背什么，我就背什么。\n\n当然，八股文肯定是准备得越充分越好。等把和自己简历强相关的八股文背完后，如果有时间，去网上搜集一些经典高频八股文，准备一下肯定是更加分的。\n\n\n\n### 4、视角切换\n\n很多同学由于没有过实习和招聘经验，写出的简历很容易停留在 “学生思维”。\n\n举个经典的例子：很多同学会在简历上写自我评价，比如 “我的学习能力强”。\n\n写自我评价本身没什么问题，但一定要有说服力。因为从招聘者的角度，如果不给出具体的事例证明，完全就是你在自夸而已。\n\n如果你要证明自己的学习能力强，就列举一些自学的例子、学习获奖的经历等等；证明自己写文档的能力强，就贴上自己写过的文档链接等。\n\n还有个例子，有些同学会觉得简历上的内容写得越多越好，甚至能写到 3 页纸。但事实上，简历内容在精不在多，就跟做视频一样，你能用最短的内容给别人讲明白一个知识点，效果会比长篇大论来解释更好。所以，尽量避免凑字数、写重复的技术、写重复的项目、写 “正确的废话”。\n\n当然，这也不绝对，在你的简历还写不满一页的时候，有啥就写啥吧，后期持续优化，优胜劣汰。\n\n我们要试着切换视角，想象一下，你如果是面试官，看到自己的这份简历，会问什么问题、觉得哪里写得好或不好。\n\n\n\n### 5、有的放矢\n\n这个技巧比较适用于时间较多、准备较充分、特别想进某个公司的同学。\n\n想象一下，如果你是一家公司的老板，现在有 2 名同学投递了简历。一位同学的简历是通用的，可以投递给所有公司；而另一位同学的简历是针对你们公司做了特定优化的，比如添加了公司的 Logo、在个人优势中响应了公司的价值观、对公司的业务有过研究等等。\n\n> 我在投递字节跳动时，给个人特点那里加了 “追求极致”，不知道是不是心理作用，反正也过了。\n\n你会更倾向于录取哪位同学呢？答案大概率是后者对吧。\n\n大家具体可以怎么做呢？\n\n有时间的同学，可以仔细阅读公司的岗位描述、并且提前去网上了解下公司的业务和系统，有的放矢，针对性地准备项目和简历。\n\n举个例子，你想进字节跳动的抖音电商部门，如果你的简历上能有一个 “简化版抖音” 的项目，或者能够对电商业务有进一步的理解，肯定是加分的。如果你对这家公司的业务做过市场调研，分析过他们的系统或网站，能够直接在简历上给他们一些建议（帮忙修一些他们的 Bug），也是大大加分的。\n\n\n\n### 6、差异化\n\n前面也提到了，现在很多同学的简历，尤其是项目经历这块，写得都差不多，没有什么区分度。\n\n在很多年以前，是只要你的技术水平达到了公司的要求，就有被发起面试的机会；但是现在计算机行业在慢慢恢复平淡，大家现在都是海投公司、每个公司可能都要收到成百上千份简历、岗位数又是有限的，如果你的简历还和大家一模一样，那么得到面试机会的概率就没那么高了。\n\n想要让自己的简历从海选中脱颖而出，一定要有一些差异化的内容。\n\n除了前面提到的 “一专多长”，要有至少一个有点深度的技术外，还有很多给简历增加区分度的方法。比如，给网络热门项目换皮，并且自主增加 2 - 3 个原本项目没有的功能；再比如去学一个相对新一点的技术、或者网上教程比较少的技术，比如后端的云原生相关中间件、服务网格、Serverless、DDD 架构设计等等。\n\n此外，如果你能有一些开源项目、或者个人上线项目经历的话，也能进一步突出自己的实践能力。告诉面试官：你不止能跟着教程完成项目，而是真的能 **自己做项目** 。\n\n\n\n### 7、持续复盘\n\n有同学向我抱怨过：鱼皮，我已经投了 1000 份简历了，为什么还是没回复呢？\n\n大家觉得会是什么原因？\n\n首先必须承认，就业环境是一个因素，但更多的则是这位同学本身的简历（或者投递简历的方式）是存在问题的。\n\n不幸的是，有些同学意识不到这点，可能就直接放弃了。\n\n需要注意的是，求职是一个 **持续的过程** 。不要因为前期的投递没有回复，就去否定自己，能用初版简历得到面试机会的，毕竟还是少数人。\n\n改变不了环境和学历等硬性条件，我们要做的便是改变自己。\n\n- 简历没有回复，就去对比其他同学的简历，持续学习来完善自己的简历，而不是始终拿老的同一份简历投递。\n- 面试不通过，就分析自己哪些面试题答的不好，或者是计算机基础不过关等等。在面试后立刻去把这些题目搞懂。\n\n我最初是在大二时就向腾讯等一线大厂投递了简历，由于当时的简历太菜，没有任何一家的回复。但是我持续更新自己的简历，等到大三暑期实习还没正式开放前，就收到了多个城市腾讯的主动面试邀请。\n\n总之一句话，秋招路漫漫，你要始终往前走，而不是原地等待好运降临。\n\n\n\n### 8、保持理性\n\n现在大家都比较焦虑，网上也有很多 “前端已死”、“后端已凉” 的言论。\n\n其实客观来看，从 22 年、甚至再早一些的时候，计算机的红利期就已经过去了。现在并不是说学计算机就找不到工作，只不过门槛提高了，不再像是几年前随便学点儿 servlet、学点儿前端三件套就能找到工作了而已。\n\n面对这种情况，我们还是要保持理性，思考一下：\n\n1）学计算机真的找不到工作么？还是说幸存者偏差，找到工作的不说话，找不到工作的组团抱怨？\n\n2）现在临时转行、或者突然放弃，对你来说是不是一个最优解？除了计算机之外，自己适合哪些工作呢？其他工作就好找么？\n\n如果你不学计算机的话，还有更好的选择，那么当然可以不学；但如果你只是因为这些言论和一些短暂的失败就 **轻易放弃自己学了几年的技术** ，尝试其他的方向，就能找到工作了么？\n\n理性客观地看待问题，做好自己该做的事情，总比跟风抱怨、或者什么都不做要好。\n\n\n\n### 9、建立连接\n\n所谓建立连接，就是尽可能多地认识大佬，积累人脉。\n\n举个最简单的例子，如果某家公司只招一个人，你是面试官，有两个候选者，一个人是你的朋友，另一个人你完全不认识，你会录取哪个人呢？\n\n建立连接其实是件很简单的事情，你可以多和学长学姐交流，如果他们进了公司，自然可以帮你内推；你可以多和面试官交流，在面试结束后主动询问联系方式，说不定后面他有其他的机会还能给你推荐；你可以多和 HR 交流，关系好了甚至可以得到一些行业内幕。\n\n此外，还可以通过写博客、开源社区、交流会等方式，认识更多同行者，一方面是抱团取暖，另外一方面，也是需要向上社交。想象一下，如果你的好友列表里有一位编程大牛，在求职中遇到了问题可以向他请教，能帮你节省多少时间？\n\n这是我之前收到的字节邀请，就是从 GitHub 上认识了我：\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1/image-20230714153452496.png)\n\n再讲个我个人的小故事，也是之前分享过的真实经历。我在回老家的路上坐车时，认识一位阿里的老乡，路上聊的甚欢，就加了微信。后面没多久，大佬就给我抛阿里 P6 的橄榄枝了。\n\n\n\n### 10、时间管理\n\n大家每天都是 24 小时，有人一天能做 5 件事，有人一天却完不成 1 件事。\n\n为什么？\n\n除去天赋和能力的区别，时间管理是一个影响效率的核心因素。\n\n秋招的时间是有限的，大家就更要做好时间管理，才能比别人跑的更快。\n\n怎么做好时间管理呢？简单来说，3 件事：\n\n1）制定计划：每天都想好自己接下来要做什么，定制好周目标、月目标、总目标等\n\n2）安排优先级：优先做对于实现你目标来说性价比最高的事情，比如你现在简历还没准备好，就先写简历；发现简历没项目，就先把重点放在项目上，尽量提高自己的简历通过率，而不是每天花过量时间去背八股文，结果反而没有面试机会。\n\n3）时间 “复用” ：时间有限的情况下，尽量用同一份时间做好多件事。\n\n举个例子，你在背八股文的过程中，如果学到了一个自己之前完全没接触过的知识，会怎么办？\n\n大多数同学会说：背下来！\n\nOK，这当然没问题。不过聪明的同学，可能会这么做。\n\n我把这个知识搞懂，然后补充到简历上；如果合适的话，再把这个知识点运用到项目中。这样既通过实践理解了题目，又完善了简历和项目。\n\n比如背到 MySQL 性能优化的知识点时，就把那些方法（比如添加索引、Explain 分析）应用到项目中实际测试下效果， 给你的印象肯定会更深刻。\n\n当然，这必然会花费额外的时间，只是给大家一种选择的思路。比起单纯的死记硬背，这种方式更有利于整体的进步。\n\n\n\n---\n\n\n\nOK，以上就是想给学弟妹们的一些秋招建议，洋洋洒洒 4000 多字，有帮助的话，点个赞吧~",
        "category": "文章",
        "cover": "https://pic.code-nav.cn/post_cover/1601072287388278786/s01wbhSE-640.jpg",
        "language": null,
        "viewNum": 87,
        "thumbNum": 8,
        "favourNum": 3,
        "commentNum": 0,
        "priority": 0,
        "userId": "1601072287388278786",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-07-17T06:26:44.000+00:00",
        "updateTime": "2023-07-24T02:57:45.000+00:00",
        "user": {
          "id": "1601072287388278786",
          "planetCode": "1",
          "userName": "程序员鱼皮",
          "userAvatar": "https://pic.code-nav.cn/user_avatar/1601072287388278786/9vqTr3HM-WechatIMG1287.jpeg",
          "gender": 1,
          "userProfile": "这个网站的老大",
          "userRole": "admin",
          "interests": [
            "C++",
            "Java",
            "Python",
            "算法"
          ],
          "place": "上海",
          "birthday": "1998-11-03",
          "school": "东华大学",
          "major": "网络工程",
          "education": null,
          "graduationYear": 2020,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": 2,
          "direction": "后端",
          "goal": null,
          "github": "https://github.com/liyupi",
          "blog": "https://yupi.icu",
          "score": 1880,
          "coin": 170,
          "followeeNum": 914,
          "followNum": 6,
          "followStatus": null,
          "vipExpireTime": "2024-05-24T03:35:38.000+00:00",
          "lastLoginTime": null,
          "createTime": "2022-12-09T04:32:33.000+00:00",
          "updateTime": "2023-07-24T03:45:41.000+00:00"
        },
        "tags": [
          "文章",
          "校招",
          "面试",
          "求职"
        ],
        "fileList": null,
        "videoList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1678810191656652801",
        "title": "目前 毕业典礼刚过 上家公司辞掉了（当下环境找工作比想象难...） 目前在找工作",
        "description": "皮哥好  最近都在投简历中 断断续续 投了也有200多份把（最近） 但是 好像没什么线上面试（只有线下的） 想让您帮看下简历，分析下是什么原因 是.net原因 还是个人技术还需要沉淀 还是？总之谢了！",
        "content": "\n![汪启明.png](https://pic.code-nav.cn/post_picture/1668342245532643329/SsNuQThW-汪启明.png)",
        "category": "文章",
        "cover": "https://pic.code-nav.cn/post_cover/1668342245532643329/JiLUjeHL-汪启明.png",
        "language": null,
        "viewNum": 91,
        "thumbNum": 0,
        "favourNum": 0,
        "commentNum": 1,
        "priority": 0,
        "userId": "1668342245532643329",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-07-11T16:55:15.000+00:00",
        "updateTime": "2023-07-23T12:52:32.000+00:00",
        "user": {
          "id": "1668342245532643329",
          "planetCode": "23557",
          "userName": "明微漾+15207082567",
          "userAvatar": "https://thirdwx.qlogo.cn/mmopen/vi_32/QOpd26S7DURXtQwjpOoczo3Hv4f1qQTPlRbYxPiafLibfbwRnU4Vw8HzFvb0qsdJukibmMegiafSanibuDByethclvA/132",
          "gender": null,
          "userProfile": null,
          "userRole": "vip",
          "interests": null,
          "place": null,
          "birthday": null,
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": null,
          "direction": null,
          "goal": null,
          "github": null,
          "blog": null,
          "score": 0,
          "coin": 0,
          "followeeNum": 0,
          "followNum": 1,
          "followStatus": null,
          "vipExpireTime": "2024-06-12T20:01:50.000+00:00",
          "lastLoginTime": null,
          "createTime": "2023-06-12T19:39:22.000+00:00",
          "updateTime": "2023-07-11T16:55:28.000+00:00"
        },
        "tags": [
          "简历",
          "文章"
        ],
        "fileList": null,
        "videoList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1678745371980861442",
        "title": "除了 MySQL，这些数据库你都认识么？",
        "description": null,
        "content": "大家好，我是鱼皮，今天来聊聊数据库。\n\n什么是数据库？\n\n这个问题相信对学编程的朋友们来说过于简单了，大家想必都是增删改查的好手。\n\n但如果让你说出 10 种不同类型的数据库，阁下该如何应对？\n\n这篇文章，是对数据库技术的一个小科普，希望能帮大家了解到更多元化的数据库，便于拓宽学习思路和项目的技术选型。\n\n\n\n## 关系型数据库\n\n首先是我们接触最多的、也是入门后端必学的 **关系型数据库** 。\n\n在关系型数据库中，数据以 **表** 的形式进行组织和存储，每个表就像一个 Excel 表格，包含多个 **行** 和多个 **列** 。\n\n就比如我们经典的学生管理系统，把学生信息存储到关系型数据库中，结构大概是这样的：\n\n| 学号 | 学生姓名 | 所属班级号 |\n| ---- | -------- | ---------- |\n| 1    | 小李     | 1          |\n| 2    | 小鱼     | 2          |\n| 3    | 小皮     | 3          |\n\n上述学生表格中，每一行代表一个学生的信息，每一列代表学生的一个属性。我们可以使用结构化查询语言 SQL 来对关系型数据库表的数据进行灵活地查询、选择、过滤等。\n\n而关系型数据库最大的特点，就是表和表之间可以 **存在关系** 。比如学生管理系统中还可以有班级表，结构如下：\n\n| 班号 | 班级名称 |\n| ---- | -------- |\n| 1    | 快乐班   |\n| 2    | 泰酷班   |\n| 3    | 躺平班   |\n\n那如果我想知道某个学生所属的班级信息，只需要在查询时将学生表的 **所属班级号** 和班级表的 **班号** 进行关联，而不用把所有表格的列存储在一起，非常灵活。\n\n通过 SQL 可以连接查询多张表，得到下面的查询结果：\n\n| 学号 | 学生姓名 | 所属班级号 | 班级名称 |\n| ---- | -------- | ---------- | -------- |\n| 1    | 小李     | 1          | 快乐班   |\n| 2    | 小鱼     | 2          | 泰酷班   |\n| 3    | 小皮     | 3          | 躺平班   |\n\n\n\n除了查询灵活、数据表间存在关系外，关系型数据库还具有很多其他的优点。\n\n比较重要的是 **数据一致性** ，关系型数据库遵循 ACID 原则（原子性、一致性、隔离性和持久性），支持事务，可以保证多个操作同时进行时，数据的状态保持一致。比如 A 给 B 转账，A 扣钱 的同时 B 也会加钱，不会出现 A 扣了钱 B 却没收到钱的情况。\n\n兼顾查询的灵活和写入的准确性，使得关系型数据库几乎可以被应用于任何项目中！比如 CRM（客户关系管理）和 HRM（人力资源管理）等各类管理系统、数据分析系统、金融银行系统等。\n\n比较经典的关系型数据库产品有 MySQL、Oracle、PostgreSQL、Microsoft SQL Server 等。其中，MySQL 由于开源又易学，已经成为后端开发同学必学的数据库技术。\n\n关系型数据库的底层核心实现是 **基于关系模型的数学理论** ，最常见的实现方式是使用 B+ 树来存储索引结构，基于其平衡性，能够在存储大量数据时保持高效的查询性能，并且兼顾增删改操作的性能。\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1/image-20230710143858899.png)\n\n对于大多数项目，用 MySQL 等关系型数据库来存储数据就足够了。但关系型数据库不是银弹！在某些场景下，比如要存储的数据间没有关系时，它并不是最佳的选择。\n\n举个例子，当我们要写一篇文章，没有必要把数据存储到 Excel 表格里，可能直接将单篇文本放到 Word 里会更方便阅读和修改。\n\n这个时候，我们就需要与之互补的 **非关系型数据库** 。\n\n\n\n## 非关系型数据库\n\n非关系型数据库又叫 NoSQL。最简单的理解方式：关系型数据库适用于存储相互之间 **存在关系的数据表** ，那么非关系型数据库适用于关系不强的、结构相对灵活的、需要被快速访问的数据，比如字符串、JSON 等。\n\n实际项目开发中，最常用的非关系型数据库当属 KV 数据库。\n\nKV 即 Key-Value，数据是以 **键值对** 的方式存储在数据库中的。可以理解为一个 HashMap，数据库中存储的每个键都 **唯一对应** 一个值。键和值都可以是任意类型的数据，例如字符串、数字、数组等，非常灵活。\n\n比如存储每位用户的个人信息，结构大概是这样的：\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1/image-20230710155319420.png)\n\n由于 KV 存储的结构简单清晰，我们能够很轻松地根据某个键查找出对应的值，无论是读写数据性能都非常高。\n\n此外，KV 数据库还具备良好的可扩展性，由于数据间不存在直接关联，我们可以把键值对放到多个机器上存储，通过数据分片、负载均衡等策略来支持海量数据的高并发访问。\n\n由于高性能和高可扩展性，KV 数据库被广泛应用于缓存、分布式会话、分布式锁、实时统计等场景。\n\n最经典的 KV 数据库当属 Redis 了，它是开源的、基于内存的、高性能的数据库，不仅支持丰富的数据类型和功能，还有持久化等重要特性，也是后端同学必学的技术。其他的常用 KV 数据库有 LevelDB、RocksDB、Apache Cassandra 等。\n\nKV 数据库的底层实现比较灵活，常见的实现方式是使用哈希表来存储键值对。不同类型的值对应的实现方式也不同，比如 Redis 的字符串存储采用简单动态字符串（SDS）实现。\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1/image-20230710161101832.png)\n\n\n\n## 解决特定问题的数据库\n\n相信很多同学对数据库的印象就停留在 MySQL 和 Redis。的确，以上两类数据库几乎已经可以解决所有问题！\n\n但是，未必是最适合的。\n\n就像你完全可以用电脑自带的记事本软件来查看和编辑 HTML 网页文件，但是往往会选择一个更专业的开发工具来替代它。\n\n数据库也是一样，除了传统的关系和非关系型数据库之外，还有很多用于解决特定问题的数据库。它们往往针对特定的数据结构和应用场景进行了专门的优化和设计，能够提供更高效快捷的数据查询和存储，满足特定领域的需求。\n\n比如下面 8 种数据库：\n\n\n\n### 搜索引擎数据库\n\n顾名思义，搜索引擎数据库是为了实现搜索引擎功能的数据库。\n\n它适用于存储和管理大量的文本内容数据，并提供更快速、准确、灵活的全文检索功能。\n\n比如想要让用户更轻松地在你的博客内搜索文章，就可以使用搜索引擎数据库。\n\n为什么它能做到更快更灵活的搜索呢？这是因为在搜索引擎数据库中，数据一般是以 **倒排索引** 的方式存储的。\n\n倒排索引和传统的关系表有什么区别呢？\n\n以存储博客文档为例，传统的关系型数据库存储结构是：\n\n| 文档 id | 文档内容             |\n| ------- | -------------------- |\n| 1       | 感谢关注鱼皮         |\n| 2       | 鱼皮是一名程序员     |\n| 3       | 感谢关注屑老板不破产 |\n\n我们能够根据 id 来查找到对应的单篇文档，也可以通过搜索精确的关键词，来查找到多篇文档。\n\n比如搜索 “鱼皮”，能搜出文档 1、2。\n\n但是，如果你搜索 “鱼皮程序员”，是无法得到搜索结果的，因为没有任何一个文档的内容，完全包含 “鱼皮程序员” 这个词（文档内容 2 只有 “鱼皮”、“程序员” 这两个词）。\n\n而在搜索引擎数据库中，首先会将文档内容按照单词进行分割，也就是 **分词** 。然后再构建单词到文档 id 的映射，示例结构如下：\n\n| 单词   | 文档 id |\n| ------ | ------- |\n| 感谢   | 1, 3    |\n| 关注   | 1, 3    |\n| 鱼皮   | 1, 2    |\n| 程序员 | 2       |\n\n\n\n有了上述的倒排索引，当用户搜索 “鱼皮程序员” 时，搜索引擎数据库会先对搜索词进行分词，得到 “鱼皮” 和 “程序员”，然后根据这两个词汇就能找到文档 id 1、2 了。不用再去遍历表内所有的数据，实现了更灵活、快速的 **模糊搜索** 。\n\n此外，搜索引擎数据库还支持 **相关性排序** ，能够根据用户的搜索词对所有搜索结果进行打分，把最接近的文档排到最上面。\n\n主流的搜索引擎数据库技术有 Elasticsearch、Apache Solr、Apache Lucene 等，一般更建议大家学习 Elasticsearch，这玩意更新迭代地老快了。\n\n\n\n### 文档数据库\n\n顾名思义，文档数据库适用于存储和管理 **半结构化的** 文档数据，比如存储 JSON 格式。\n\n相比于关系型数据库中明确定义的表格行列，文档数据库的数据结构是类似于文档的层次化结构，每个文档都是独立的，可以包含多个不同类型和格式的数据。\n\n比如存储博客文章，示例结构如下：\n\n| 文档 ID | 文档数据                                                     |\n| ------- | ------------------------------------------------------------ |\n| 1       | {\"_id\": 1, \"title\": \"文章标题1\", \"content\": \"这是文章1的内容\"} |\n| 2       | {\"_id\": 2, \"title\": \"文章标题2\", \"author\": \"程序员鱼皮\"}     |\n\n\n\n当我们要给某个文档新增一个字段时，不需要像关系型数据库一样改变表结构，非常灵活！\n\n除了灵活之外，文档数据库也有很高的可扩展性，适用于内容管理系统（比如博客）、文档协同编辑系统等。\n\n个人比较推荐学习的文档数据库是 MongoDB，入门难度极低，对前端同学也很友好。当然，Couchbase 也是不错的。\n\n\n\n### 时序数据库\n\n时序数据库是一种专门用于高效存储和处理 **时间序列** 的数据库系统。\n\n时间序列是指以时间作为主要维度的数据序列，即每个数据单元都包含 **时间戳** 。\n\n举个例子，在实时温度监测系统中，我们需要 **每分钟连续** 收集并观察当前的温度，数据结构示例如下：\n\n| 时间戳           | 设备ID    | 温度值 |\n| ---------------- | --------- | ------ |\n| 2023-07-01 10:00 | Device001 | 25.5   |\n| 2023-07-01 10:01 | Device001 | 25.7   |\n| 2023-07-01 10:02 | Device001 | 25.8   |\n| 2023-07-01 10:03 | Device001 | 26.2   |\n| 2023-07-01 10:04 | Device001 | 26.5   |\n| 2023-07-01 10:05 | Device001 | 26.3   |\n\n\n\n有了这些数据，我们就能够按照时间范围进行高效查询、聚合分析、数据可视化。\n\n因此，时序数据库非常适用于物联网（比如传感器数据）、日志监控、金融交易数据分析等场景。\n\n主流的时序数据库技术有 InfluxDB、TimescaleDB 等。一般情况下，建议将时序数据库配合 Grafana 监控看板一起使用，实现数据存储 + 快速可视化。\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1/image-20230710175458997.png)\n\n不同时序数据库底层的存储方式也不同，我们可以简单理解为，时序数据库会根据 **时间** 字段构建索引，查询时通过索引去定位实际数据。比如 InfluxDB 使用 TSM（Time-Structured Merge Tree）作为存储引擎，底层使用 B+ 树来存储时间索引。\n\n\n\n### 向量数据库\n\n向量数据库是专门用于存储和处理 **高维向量数据** 的数据库系统。\n\n什么是向量？每个向量可以表示一个实体，并且包含多个维度的数值。\n\n举个例子，在人脸识别系统中，我们可以通过人脸的 **特征** 来判断是否为熟人。每张人脸图像，都对应一个向量；每个人脸向量有可能包含成百上千个特征，比如鼻子大小、眼睛大小等，每个特征就是一个维度。\n\n对应的数据结构示例如下：\n\n| 人脸 ID | 人脸特征向量              |\n| ------- | ------------------------- |\n| 1       | [0.1, 0.2, 0.3, ..., 0.5] |\n| 2       | [0.1, 0.3, 0.2, ..., 0.4] |\n\n\n\n在上述表格中，人脸特征向量是一个浮点数数组。数组的每个下标就表示一个特征（维度），比如下标 0 的数值表示鼻子的大小，下标 1 的数值表示眼睛大小，以此类推。。。\n\n我们只需要对比向量，就能够判断出人脸的相似度。\n\n向量数据库能够高效存储多维向量数据、计算向量的相似度、并实现各种不同算法的相似性搜索，适用于图像识别、特征提取和匹配、推荐系统等场景。值得一提的是，AI 技术的发展也带来了一波向量数据库技术的热潮，可以利用向量数据库存储投喂给 AI 的训练 Embeddings 数据。\n\n主流的向量数据库技术有 Milvus、Pinecone、Faiss 等，有些数据库（比如 PostgreSQL）可能也支持存储向量类型的字段。\n\n关于向量数据库的底层实现，还是比较复杂的。类似于上面提到的时序数据库，向量数据库的实现关键也是索引的设计。常见的向量索引结构有倒排索引、KD 树、球树等，可以理解为对相似的向量数据进行了分组和编码，从而实现更快速地检索匹配相似向量。此外，向量数据库往往也会采用并行计算来加速处理。\n\n\n\n### 空间数据库\n\n空间数据库是专门用于存储和处理 **地理空间数据** 的数据库系统。\n\n地理空间数据是指基于地理 **坐标系** 的 **几何对象** ，比如某个物体所处的经纬度或三维坐标（点）、某个物体的轮廓（线）、某个物体的表面（面）等。\n\n举个例子，假如你想存储自己房间内每个物体的位置信息，对应的数据结构可能是：\n\n| 物体 ID | X 坐标 | Y 坐标 | Z 坐标 |\n| ------- | ------ | ------ | ------ |\n| 1       | 2.5    | 3.0    | 1.8    |\n| 2       | 1.0    | 4.2    | 2.3    |\n| 3       | 3.7    | 2.1    | 1.5    |\n\n\n\n使用空间数据库，能够高效地存储、查询和分析空间数据，比如计算两个空间是否相交、对路径进行规划、可视化地理空间等。\n\n空间数据库不仅是地理信息系统（GIS）的核心组件，还能用于实现位置导航、城市路面规划等场景。\n\n对于具体的空间数据库技术，我了解得不多，只知道可以用 PostGIS 插件来为 PostgreSQL 支持空间数据管理能力，朋友们可以帮忙补充下。\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1/image-20230710175715334.png)\n\n至于空间数据库的底层实现，最关键的部分依然是索引。常见的 **空间索引** 结构有 R 树、Quadtree 等，这些结构可以对空间数据进行划分、聚合和编码，从而加速空间范围的查询处理。此外，空间数据库涉及大量的空间分析算法，比如最近邻查询、空间关系查询等。时间有限，不做展开说明了。\n\n\n\n### 图形数据库\n\n图形数据库是专门用于存储和处理 **图形结构数据** 的数据库系统。\n\n注意，这里的图形可不是三角形、长方形，而是指 **由节点和边构成** 的图形结构。\n\n比如我们要存储一个朋友圈关系网（即 FoF：朋友的朋友），对应的图形可能是：\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1/image-20230710180107393.png)\n\n上图中，每个用户可以表示为一个节点，用户之间的好友关系可以表示为边。\n\n在图形数据库中，需要 2 个表格来存储。\n\n节点信息表：\n\n| 节点 id | 节点名 |\n| ------- | ------ |\n| 1       | 小王   |\n| 2       | 小李   |\n| 3       | 小刘   |\n\n边信息表：\n\n| 边 id | 边类型 | 起始节点 | 结束节点 |\n| ----- | ------ | -------- | -------- |\n| 1     | 好友   | 1        | 2        |\n| 2     | 好友   | 1        | 3        |\n\n\n\n通过存储这些节点和边的信息，图形数据库就能实现快速 **查询及分析** 朋友圈网中的用户关系，并且挖掘出用户的社交情况、和其他用户的隐藏关系等。\n\n由此，图形数据库非常适于构建社交网络关系图谱、推荐系统、知识图谱等。\n\n比较主流的图形数据库有 Neo4j、TigerGraph 等，都支持复杂的图形操作和算法、以及分布式扩展，能够通过并行计算加速图形处理。\n\n图形数据库的核心实现相信学过算法的朋友们并不陌生，主要是用了类似邻接表、邻接矩阵等方式实现节点和边数据的存储，并且通过构建图形索引进行加速。\n\n\n\n### 列存数据库\n\n这是一种 **非常主流** 的数据库！区别于传统的行式数据库，列存数据库以列作为基本的存储单位，把每列的数据存储在一起。\n\n拿鱼皮公司每天的收入来举个例子，传统的行式（关系型）数据库是这么存储的：\n\n| 日期       | 销售额 | 成本 | 利润 |\n| ---------- | ------ | ---- | ---- |\n| 2022-01-01 | 500    | 600  | -100 |\n| 2022-01-02 | 280    | 450  | -170 |\n| 2022-01-03 | 290    | 480  | -190 |\n\n而在列存数据库中，底层大概是这么存储的，相当于对矩阵做了一次转置：\n\n| 日期   | 2022-01-01 | 2022-01-02 | 2022-01-03 |\n| ------ | ---------- | ---------- | ---------- |\n| 销售额 | 500        | 280        | 290        |\n| 成本   | 600        | 450        | 480        |\n| 利润   | -100       | -170       | -190       |\n\n\n\n这样一来，如果我们要统计这几天公司的总利润，不需要依次读取每一行的数据，直接 **读取所需** 的利润那一列进行计算即可，从而提高了数据分析和聚合操作的效率。\n\n此外，从计算机底层来分析，把相同类型的数据在同一列中连续存储，可以实现更好的数据压缩效果、节约空间。\n\n因此，列存数据库适用于实时数据分析、OLAP、大规模数据仓库等场景。\n\n比较主流的列存数据库技术有 Apache HBase、ClickHouse、Druid 等，都是大数据方向同学的必修课。\n\n![ClickHouse 官方演示](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1/image-20230710184405730.png)\n\n\n\n### 多模数据库\n\n最后要讲的数据库也最特别，区别于上面所有存储单一数据模型的数据库，多模数据库能够 **同时存储处理多种不同类型的数据** ，比如关系型数据、文档数据、图形数据等，非常灵活。\n\n就拿大家学编程时最常做的电商系统来举例。如果没有多模数据库，你要用关系型数据库来存储商品简略信息（比如商品名称、价格），要用文档数据库来存储可能长达几十页的商品详情，要用图数据库来存储商品推荐关系。每次看数据库信息时，要分别到三个数据库中查看。\n\n如果使用多模数据库，可以直接在同一个数据库里统一存储和管理不同类型的数据，非常方便。\n\n此外，多模数据库还支持事务，能够更轻松地实现数据的一致性和完整性，不需要手动实现跨库事务、跨库数据同步等等。\n\n比较常用的多模态数据库技术有 ArangoDB、OrientDB 等，不过一般情况下，我们在开发中也很少会用到这种数据库，感兴趣的话再学习即可。\n\n\n\n---\n\n\n\nOK，不知不觉竟然写了近 6000 字！希望这篇文章对大家有收获吧，不过我只列举了应用相对较多的数据库类型，大家如果听说过其他的数据库，欢迎评论区留言分享~",
        "category": "文章",
        "cover": "https://pic.code-nav.cn/post_cover/1601072287388278786/c4xC84Ol-640.jpg",
        "language": null,
        "viewNum": 98,
        "thumbNum": 4,
        "favourNum": 2,
        "commentNum": 0,
        "priority": 999,
        "userId": "1601072287388278786",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-07-11T12:37:40.000+00:00",
        "updateTime": "2023-07-24T02:59:51.000+00:00",
        "user": {
          "id": "1601072287388278786",
          "planetCode": "1",
          "userName": "程序员鱼皮",
          "userAvatar": "https://pic.code-nav.cn/user_avatar/1601072287388278786/9vqTr3HM-WechatIMG1287.jpeg",
          "gender": 1,
          "userProfile": "这个网站的老大",
          "userRole": "admin",
          "interests": [
            "C++",
            "Java",
            "Python",
            "算法"
          ],
          "place": "上海",
          "birthday": "1998-11-03",
          "school": "东华大学",
          "major": "网络工程",
          "education": null,
          "graduationYear": 2020,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": 2,
          "direction": "后端",
          "goal": null,
          "github": "https://github.com/liyupi",
          "blog": "https://yupi.icu",
          "score": 1880,
          "coin": 170,
          "followeeNum": 914,
          "followNum": 6,
          "followStatus": null,
          "vipExpireTime": "2024-05-24T03:35:38.000+00:00",
          "lastLoginTime": null,
          "createTime": "2022-12-09T04:32:33.000+00:00",
          "updateTime": "2023-07-24T03:45:41.000+00:00"
        },
        "tags": [
          "文章",
          "数据库"
        ],
        "fileList": null,
        "videoList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1676868456286261249",
        "title": "自我介绍，千万别来虚的！",
        "description": null,
        "content": "大家好，我是鲏。\n\n已经帮小伙伴改了 500 多份简历了，也发现了一些大家写简历时的共性问题。其中让我印象比较深刻的一个点就是 **自我介绍** ，基本上所有同学的自我介绍都是这么写的：\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/640.png)\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/640-20230706145231040.png)\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/640-20230706152710307.png)\n\n读这篇文章的朋友们，你是不是也是这么写自我介绍的呢？\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/640-20230706152643341.png)\n\n这么写看上去好像没什么问题，我学生时代最初的简历也是这么写的。\n\n但别忘了，你的简历是给别人看的！\n\n如果我们从面试官的角度（或者其他人的角度）客观来看，这些话无疑是正确的废话，不过是拿来凑简历字数的而已。\n\n为什么？\n\n道理很简单，夸自己谁不会呢？所以绝大多数的简历上都会出现雷同的自我评价，如果是一个热门岗位，估计面试官都能把这些内容背下来了。\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/640-20230706145231091.png)\n\n关键的问题是，**怎么样让你的自我评价有信服力** 。需要一些事例、数据、证据来证明。\n\n举些例子：\n\n1. 我学习能力强，对新技术有强烈的好奇心 => 补充：曾通过官方文档、自主查阅资料自学了 XX、XX 新技术，并通过 RSS 持续关注该技术最新动态。\n2. 我乐于从事有挑战性的工作 => 补充：我曾经担任 XX 队长，在 XX 困难的条件下，解决了 XX 问题，取得了 XX 成果。\n3. 我喜欢分享知识、善于总结 => 补充：连续 XX 天发布个人博客，发布过 XX 个学习总结等等\n4. 我很帅 => 补充个人照片\n\n这样写自我评价，就不再是虚的了，而是真的能让对方感受到你的这些能力。\n\n这里有个小技巧，可以照着目标公司的岗位描述去写自我评价，做到对号入座。\n\n![到官网看岗位描述](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/640-20230706145231138.png)\n\n比如公司要求招有团队协作经验的，那就写：我善于团队合作，曾经组队参与 XX、XX 项目，统筹负责了 XX、XX，怎么提升团队工作效率之类的。。。\n\n这样从招聘者的角度来看，你是有用心准备过的，目的性明确，也是加分项。\n\n除了写到简历上的自我评价外，我们在求职面试中的自我介绍也是一样的逻辑。自我介绍是需要精心准备的，而不是每次面试都现场 free style，那样很容易出现一些 “阿巴阿巴”、不知所云的情况。\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/640-20230706145231204.png)\n\n比较虚的自我介绍是：我是谁、来自 XX、求职意向是 XX 岗位，然后夸一番自己，有较强的学习能力什么的。。。\n\n而比较稳的自我介绍是：我是谁、来自 XX、求职意向是 XX 岗位，主动学过哪些技能、哪些技能学的比较好、通过什么方式自主学习，然后用事例来证明自己哪些能力比较强。\n\n比如我会说：自己拥有丰富的项目经验，大学曾带领工作室建设多少个网站，自主参与过 XX 项目和竞赛，曾在 2 家公司实习并负责 XX 工作；自己乐于分享、总结能力强，大学开展过 XX 场分享讲座等等。\n\n总之，逻辑清晰，有理有据，面试官会很喜欢你的。\n\n程序员求职面试，技术是一方面，另一方面是通过你的准备用心程度以及线上的交流来 get 到你的综合能力（沟通能力、逻辑思维能力等）。大家都学一样的技术，那么拉开差距的就是其他的能力以及你如何展现这些能力了。\n\n大概就聊到这里，大家还是要注重日常的积累，有一定经历，在写自我评价、介绍自己的时候才会更有底气。\n\n---\n\n欢迎学编程的朋友们加入鱼皮的编程学习圈子(yupi.icu) ，和上万名学编程的同学共享知识、交流进步，学习原创项目并享有答疑指导服务。",
        "category": "文章",
        "cover": "https://pic.code-nav.cn/post_cover/1601072287388278786/estZdJNB-7.6.png",
        "language": null,
        "viewNum": 205,
        "thumbNum": 7,
        "favourNum": 3,
        "commentNum": 0,
        "priority": 999,
        "userId": "1601072287388278786",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-07-06T08:19:29.000+00:00",
        "updateTime": "2023-07-24T03:46:18.000+00:00",
        "user": {
          "id": "1601072287388278786",
          "planetCode": "1",
          "userName": "程序员鱼皮",
          "userAvatar": "https://pic.code-nav.cn/user_avatar/1601072287388278786/9vqTr3HM-WechatIMG1287.jpeg",
          "gender": 1,
          "userProfile": "这个网站的老大",
          "userRole": "admin",
          "interests": [
            "C++",
            "Java",
            "Python",
            "算法"
          ],
          "place": "上海",
          "birthday": "1998-11-03",
          "school": "东华大学",
          "major": "网络工程",
          "education": null,
          "graduationYear": 2020,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": 2,
          "direction": "后端",
          "goal": null,
          "github": "https://github.com/liyupi",
          "blog": "https://yupi.icu",
          "score": 1880,
          "coin": 170,
          "followeeNum": 914,
          "followNum": 6,
          "followStatus": null,
          "vipExpireTime": "2024-05-24T03:35:38.000+00:00",
          "lastLoginTime": null,
          "createTime": "2022-12-09T04:32:33.000+00:00",
          "updateTime": "2023-07-24T03:45:41.000+00:00"
        },
        "tags": [
          "文章",
          "简历"
        ],
        "fileList": null,
        "videoList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1676868047337426946",
        "title": "实习没成长，想离职了",
        "description": null,
        "content": "现在各种实习招聘基本都已经结束了，很多小伙伴成功找到了实习，但依旧很焦虑。\n\n觉得虽然成功进入公司实习，但每天基本就是做增删改查的活，对自身没有提升。所以不知道是不是应该辞职去自学。\n\n刚刚开始，一般来说公司不会把核心的活交给你的，所以应该要沉住气，先把眼下的工作做到最好，要是干完活有空闲的时间可以再去多了解了解公司的业务逻辑，自己去学习提升，积累经验。\n\n以下是一个相关的经典问题，希望能给大家做一个参考。\n\n---\n\n\n\n### 小伙伴的提问：\n\n鱼哥您好，我现在实习了一周多，目前负责的是 OA 系统的开发，基本都是 crud，感觉写这些对自身的成长没有什么帮助，写这些系统最大的感觉就是都是在写业务，理解了业务自然就能写出来了，没什么技术含金量，感觉我自学都比在那写 crud 成长来得快 \n\n目前的两个月的学习进度： \n\n啃了一遍 Spring 源码，再次深入学了一遍设计模式并应用到我自己的项目中了，JUC 两周内可以学完，我现在的想法是学完 JUC 再把鱼皮最新的两个项目学完并替换我自己的 lowB 项目然后再去继续投简历，不知道时间是否来得及，也不知道是否应该再学完 jvm 再去投？  \n\n问题： \n\n1.我是否需要应该辞职回校自学？如果回校自学我担心缺少一段实习经历对我秋招求职会有很大影响 \n\n2.现在也是银四阶段，我是否应该继续投递简历选择一家更好的公司？ \n\n3.我想知道一个公司的实习生(Java 后端方向)应该负责什么业务会对其自身成长有较大的帮助 \n\n4.我询问其他实习的同学，他们都说实习阶段公司都是把你当新人，基本不会给有难度的活给你干的，到时简历书写实习经历时，把自己个人的有含金量的项目搬到实习经历那里即可，这种做法是否可取呢？\n\n\n\n### 鱼皮答：\n\n说下我自己的感受哈，我觉得小伙伴有点点浮躁了，或者说对于实习工作的预期太高。 \n\n本来你作为实习生，才实习一周多，系统可能都没完全熟悉呢，公司怎么会把核心的业务、有挑战的事情交给你呢？（创业公司除外）即使是正式工作，很多公司的工作内容也不会特别有挑战，增删改查肯定还是大多数，即使等你正式工作了一样是写业务，到时候也不能说跑就跑。\n\n记得我第一次实习，因为业务复杂、我又不熟悉系统，前两周就画了个流程图，我没有抱怨，反而觉得挺开心的，感觉自己是踏实地完成了一件有复杂度的工作。虽然现在看起来也不难、而且那两周一行代码没写，但是在那时感觉还是给自己带来了不小的进步 —— 起码知道面对复杂的业务，要先理清业务流程、做好设计后再写代码。 \n\n另外我在腾讯实习得到的经验 —— 不要把业务系统想的太简单，多关注项目细节。我大三暑假实习那会儿，刚开始年轻气盛，我也觉得老大给我的需求就是增删改查、很简单，我说 3 天就能完成。结果实际开发中，遇到了各种自己没有注意到的业务细节问题（比如前人约定的一些业务规则），导致大量的返工，最后花了快 2 周才上线。 \n\n也可能是现在时代变了吧，感觉大家都挺着急的，其实你完全可以这么想：你实习有 3 个目的，1 是积累经验，2 是收获一段实习经历，3 是给自己的简历增加项目。 \n\n首先不是说这家公司在压榨你，如果觉得公司的工作简单，那你可以快速地完成工作，然后自学，而不是辞职，这样你就有了一段实习经历（一般要 2 个月左右）。\n\n 其次，你应该学会利用好公司的项目等资源来提升自己，而不是别人给你安排什么、就机械地做什么。比如你觉得项目简单，能不能把你自学到的项目优化技巧应用到这个项目中？能不能完全吃透这个项目，把它变成自己的？这比你自己从 0 开始做 1 个项目要方便多了，而且成果的体现也更明显，光明正大地写到简历上。\n\n 至于其他的问题，你可以持续投递简历，但记住我上面说的话 “别对实习的工作有太高的期待，更不要眼高手低”，折腾来折腾去说不定还没有第一家的体验好。想要自身成长，环境是一方面，更多的则取决于 “自身”，心态要端正。\n\n---\n\n欢迎学编程的朋友们加入鱼皮的编程学习圈子(yupi.icu) ，和上万名学编程的同学共享知识、交流进步，学习原创项目并享有答疑指导服务。\n",
        "category": "文章",
        "cover": "https://pic.code-nav.cn/post_cover/1601072287388278786/i7j09CYN-640 13.56.43.png",
        "language": null,
        "viewNum": 103,
        "thumbNum": 3,
        "favourNum": 0,
        "commentNum": 0,
        "priority": 999,
        "userId": "1601072287388278786",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-07-06T08:17:51.000+00:00",
        "updateTime": "2023-07-24T03:02:30.000+00:00",
        "user": {
          "id": "1601072287388278786",
          "planetCode": "1",
          "userName": "程序员鱼皮",
          "userAvatar": "https://pic.code-nav.cn/user_avatar/1601072287388278786/9vqTr3HM-WechatIMG1287.jpeg",
          "gender": 1,
          "userProfile": "这个网站的老大",
          "userRole": "admin",
          "interests": [
            "C++",
            "Java",
            "Python",
            "算法"
          ],
          "place": "上海",
          "birthday": "1998-11-03",
          "school": "东华大学",
          "major": "网络工程",
          "education": null,
          "graduationYear": 2020,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": 2,
          "direction": "后端",
          "goal": null,
          "github": "https://github.com/liyupi",
          "blog": "https://yupi.icu",
          "score": 1880,
          "coin": 170,
          "followeeNum": 914,
          "followNum": 6,
          "followStatus": null,
          "vipExpireTime": "2024-05-24T03:35:38.000+00:00",
          "lastLoginTime": null,
          "createTime": "2022-12-09T04:32:33.000+00:00",
          "updateTime": "2023-07-24T03:45:41.000+00:00"
        },
        "tags": [
          "文章"
        ],
        "fileList": null,
        "videoList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1675756953717968897",
        "title": "这些代码，差点把我气出内伤",
        "description": null,
        "content": "大家好，我是鱼皮，一个正在烂代码的泥潭里面摸爬滚打的程序员。\n\n先问大家一个小问题：你觉得看别人代码累，还是自己写代码累？\n\n我相信有很多朋友会说，当然是自己写代码累了，要思考逻辑、要动手敲键盘，身心俱疲啊；但是，如果你需要经常阅读别人的代码，尤其是烂代码，答案就不一定了。\n\n因为自己写代码，逻辑是自己来梳理的、代码自己是熟悉的；但是看别人的代码，你就要去理解别人的代码逻辑，再加上烂代码的加持，可能很简单的逻辑，你都得看半天才能懂。所以很多大佬在面对前人的 “屎山” 项目时，宁愿自己重写，也不去读烂代码。\n\n举个夸张的例子：让你实现 1 + 1 的求和\n\n自己写：\n\n```javascript\nlet sum = 1 + 1;\n```\n\n某烂代码可能是：\n\n```javascript\nlet a = {};\nlet b = {};\n\na.toString = function() {\n  return 1;\n};\n\nb.valueOf = function() {\n  return \"1\";\n};\n\nlet sum = a + b;\n```\n\n把简单的逻辑搞复杂，便是绝大多数程序员的拿手好戏（当然也包括我）。\n\n因为我从大学就开始带团队做项目了嘛，所以经常会审查团队同学的代码，做好二次校验。包括现在虽然开公司了，前端 / 后端同学的代码，也都会在我这过一遍才会发布上线。\n\n总之算是看了很多代码，其中有一些真的是让我哭笑不得。下面给大家分享一些代码片段出来，希望大家 **不要学习** 。\n\n\n\n#### 1、过于抽象的命名\n\n还记得咱们刚学编程的时候，变量的命名都是用的 abcdefg。\n\n自学时这么写完全没问题，但是在实际项目中，如果还用过于抽象的命名，那就不太合适了。\n\n比如下面这段，大家能看懂是什么意思么？\n\n```js\nconst [l, setL] = useState<boolean>(false);\nconst [d, setD] = useState<any>();\n```\n\n但如果我稍微完善下命名呢：\n\n```js\nconst [loading, setLoading] = useState<boolean>(false);\nconst [data, setData] = useState<any>();\n```\n\n很多同学应该立刻能看懂了，一个是 “加载中” 的变量，一个是 “存储数据” 的变量。\n\n最好的代码应该是不用写注释的，因为 **代码即注释** 。如果你能把命名做到 “见名知义”，看代码的人会极度舒适。\n\n\n\n#### 2、有深度的代码\n\n比如下面这段：\n\n```javascript\nif (condition1) {\n  // 逻辑 A\n  if (condition2) {\n    // 逻辑 B\n    if (condition3) {\n      // 逻辑 C\n      if (condition4) {\n        // 逻辑 D\n      }\n    }\n  }\n}\n```\n\n这里的深度有 2 重含义，一重是字面意思：代码一层嵌一层、深不见底；另外一重是指真的 “很有深度” —— 指让人看不懂。\n\n阅读这段代码的感觉就像是你在一座巨大的迷宫里，每次转弯都要判断下是左还是右，最后你只会迷失方向。\n\n如何改进呢？\n\n最简单直接的方法就是使用早返回策略（early return）：\n\n```javascript\nif (!condition1) \n\t// 逻辑 A\n\treturn;\nif (!condition2)\n  // 逻辑 B\n\treturn;\nif (!condition3)\n  // 逻辑 C\n\treturn;\nif (!condition4)\n  // 逻辑 D\n\treturn;\n```\n\n这样，你的代码就清晰了很多，阅读这种代码的感觉就像是走在了一条直路上，前方的路一目了然。\n\n当然，还可以将一些逻辑抽象成独立函数来简化代码，或者使用设计模式来优化。\n\n怎么判断一段代码是否过于复杂、应该优化了呢？这里提到一个概念： **圈复杂度** ，这是一种量化代码复杂程度的概念。通常你代码中的 if else 分支越多，圈复杂度就越高，代码就越复杂。\n\n企业中一般建议圈复杂度不要超过 10 - 15，我个人的编码习惯是一般不会在代码中出现 3 层以上的嵌套（除非必要）。\n\n\n\n#### 3、冗余代码\n\n这是我遇到最多的问题！分为 3 种情况：\n\n1. 能用一行代码搞定，偏偏要写 10 行\n2. 能用一个变量或函数搞定，偏偏每次都是复制粘贴重复写\n3. 没有用到的代码，又不舍得删除\n\n\n\n举个例子，下面这段前端代码，大家觉得有什么问题：\n\n> 这是我们鱼聪明 AI 前端开发过程的真实代码\n\n```react\n<Spin spinning={!(currDownloadUrl || originPictureUrl || pictureUrl)}>\n  {type === DRAW_APP ? (\n    drawImg(image)\n  ) : (\n    drawImg(currDownloadUrl || originPictureUrl || pictureUrl)\n  )}\n</Spin>\n```\n\n\n\n\n\n第一眼看到这段代码时，我就发现了，判断 spinning（旋转）的代码逻辑比较复杂，包含了两个 `||` 逻辑。而下面的 `drawImg` 函数的参数中，又包含了这段一模一样的逻辑。这段判断，其实就是冗余代码，完全没必要写两遍！\n\n我调整过后的代码如下：\n\n```javascript\n// 要展示的图片地址\nconst showPictureUrl = currDownloadUrl || originPictureUrl || pictureUrl;\n```\n\n直接定义一个通用变量，写上清晰的注释，其他地方要使用时就无需关注内部判断逻辑，看注释就行了。\n\n这就是所谓的 **DRY 原则**（Don't Repeat Yourself） ，尽量避免代码冗余。如果你在多处写下相同的代码，那么当需要修改这段代码时，你就需要在所有这些地方都修改，漏一个地方就是一个 Bug。\n\n还有，关于项目中没有用到的函数和变量，如果你近期没有使用计划，不妨就删除或者注释掉，别舍不得。利用好 Git 版本控制系统，只要你的代码提交信息写得好，要用到被删掉的历史代码时，去提交记录里找即可。\n\n> 注意，如果是学习时写代码，多保留一些也是合理的。但企业项目中，项目代码精简凝练些会更好。\n\n\n\n这里打个比方，写代码就像是我在公司里堆东西，一开始总觉得多一点没关系，反正有空间。但是，冗余代码就像是杂物，会越堆越多，迟早有一天，会影响到你，就像我们公司现在一样（右边有一堆杂物）：\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1/image-20230701171133600.png)\n\n\n\n大概就分享到这里，请大家在评论区 @ 出你写烂代码的同事吧 \uD83D\uDC36 ~\n\n\n\n---\n\n\n\n欢迎学编程的朋友们加入鱼皮的 [编程知识星球](https://mp.weixin.qq.com/s?__biz=MzI1NDczNTAwMA==&mid=2247539132&idx=2&sn=45af016dee0c03491750f76ba8fdbd25&chksm=e9c2be4bdeb5375d3253155b4053263109a631620b7cb9074e2fe1b4a5b1604ef92c522b606e&token=292259508&lang=zh_CN#rd) ，和 2 万多名学编程的同学共享知识、交流进步，学习原创项目并享有答疑指导服务。",
        "category": "文章",
        "cover": "https://pic.code-nav.cn/post_cover/1601072287388278786/H3EBmkIl-640.jpg",
        "language": null,
        "viewNum": 206,
        "thumbNum": 3,
        "favourNum": 0,
        "commentNum": 1,
        "priority": 999,
        "userId": "1601072287388278786",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-07-03T06:42:46.000+00:00",
        "updateTime": "2023-07-24T01:54:24.000+00:00",
        "user": {
          "id": "1601072287388278786",
          "planetCode": "1",
          "userName": "程序员鱼皮",
          "userAvatar": "https://pic.code-nav.cn/user_avatar/1601072287388278786/9vqTr3HM-WechatIMG1287.jpeg",
          "gender": 1,
          "userProfile": "这个网站的老大",
          "userRole": "admin",
          "interests": [
            "C++",
            "Java",
            "Python",
            "算法"
          ],
          "place": "上海",
          "birthday": "1998-11-03",
          "school": "东华大学",
          "major": "网络工程",
          "education": null,
          "graduationYear": 2020,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": 2,
          "direction": "后端",
          "goal": null,
          "github": "https://github.com/liyupi",
          "blog": "https://yupi.icu",
          "score": 1880,
          "coin": 170,
          "followeeNum": 914,
          "followNum": 6,
          "followStatus": null,
          "vipExpireTime": "2024-05-24T03:35:38.000+00:00",
          "lastLoginTime": null,
          "createTime": "2022-12-09T04:32:33.000+00:00",
          "updateTime": "2023-07-24T03:45:41.000+00:00"
        },
        "tags": [
          "文章",
          "Java",
          "Javascript",
          "后端",
          "前端"
        ],
        "fileList": null,
        "videoList": [],
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      }
    ],
    "total": "130",
    "size": "10",
    "current": "1",
    "orders": [],
    "optimizeCountSql": true,
    "searchCount": true,
    "countId": null,
    "maxLimit": null,
    "pages": "13"
  },
  "message": "ok"
}